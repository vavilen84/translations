# Arrays, slices (and strings): The mechanics of 'append'

Source https://blog.golang.org/slices

Author: Rob Pike 26 September 2013

# Массивы, срезы (и строки): Механизм append

## Вступление

Одна из наиболее распространенных особенностей процедурных языков программирования - это концепция массива. Массивы кажутся простыми вещами, но есть много вопросов, на которые необходимо ответить при их добавлении в язык, например:

- фиксированного или переменного размера?
- является ли размер частью типа?
- как выглядят многомерные массивы?
- имеет ли смысл пустой массив?

Ответы на эти вопросы влияют на то, являются ли массивы просто возможностью языка или базовой частью его дизайна.

На раннем этапе разработки Go потребовалось около года, чтобы найти ответы на эти вопросы, прежде чем дизайн стал правильным. Ключевым шагом было введение срезов, которые построены на массивах фиксированного размера, чтобы предоставить гибкую, расширяемую структуру данных. Однако до сих пор программисты, плохо знакомые с Go, часто спотыкаются о том, как работают срезы, возможно, из-за влияния опыта других языков.

В этой статье мы попытаемся устранить путаницу. Мы это сделаем, собрав некоторые части вместе, чтобы объяснить, как работает встроенная функция append и почему она работает именно так.

## Массивы

Массивы являются важным строительным блоком в Go, но, как и фундамент здания, они часто скрыты под более видимыми компонентами. Мы должны кратко поговорить о них, прежде чем перейти к более интересной, мощной и заметной идее срезов.

Массивы нечасто встречаются в программах Go, потому что размер массива является частью его типа, что ограничивает его выразительные возможности.

Выражение

```
var buffer [256]byte
```

объявит переменную buffer, которая будет содержать массив из 256 байт. Тип переменной buffer включает размер [256]byte. Массив из 512 байт имел бы отличный тип [512]byte.

Данные, связанные с массивом — это просто массив элементов. Схематично наш буфер в памяти выглядит так

```
buffer: byte byte byte ... 256 раз ... byte byte byte
```

То есть переменная содержит 256 байт данных и ничего больше. Мы можем получить доступ к его элементам с помощью знакомого синтаксиса индексации: buffer[0], buffer[1] и т.д. до buffer[255]. (Диапазон индекса от 0 до 255 охватывает 256 элементов.) Попытка индексировать буфер со значением вне этого диапазона приведет к сбою программы.

Существует встроенная функция len, которая возвращает количество элементов массива или среза, а также, для нескольких других типов данных. Для массивов очевидно, что возвращает len. В нашем примере len(buffer) возвращает фиксированное значение 256.

У массивов есть свое место — например, они являются хорошим представлением матрицы преобразования, но их наиболее распространенная цель в Go - хранить память для среза.

## Срезы: заголовок среза

Срезы — это то место, где происходит действие, но, чтобы правильно их использовать, нужно точно понимать, что они из себя представляют и что они делают.

Срез — это структура данных, описывающая непрерывный раздел массива, хранящийся отдельно от самой переменной среза. Срез — это не массив. Срез описывает часть массива.

Учитывая нашу переменную буферного массива из предыдущего раздела, мы могли бы создать срез, который описывает элементы от 100 до 150 (точнее, от 100 до 149 включительно), срезав массив:

```
var slice []byte = buffer[100:150]
```

В этом фрагменте мы использовали полное объявление переменной для наглядности. Переменная slice имеет тип []byte, произносится как «срез байт», и инициализируется из массива, называемого буфером, путем разделения элементов с 100 (включительно) до 150 (исключая). Более идиоматический синтаксис отбрасывает тип, который задается инициализирующим выражением:

```
var slice = buffer[100:150]
```

Внутри функции мы могли бы использовать короткую форму объявления

```
slice := buffer[100:150]
```

Что именно представляет собой эта переменная среза? Мы имеем не совсем полную картину, но пока представьте себе срез как небольшую структуру данных с двумя элементами: длиной и указателем на элемент массива. Вы можете думать об этом как о чем то созданном за кулисами:

```
type sliceHeader struct {
    Length        int
    ZerothElement *byte
}

slice := sliceHeader{
    Length:        50,
    ZerothElement: &buffer[100],
}
```

Конечно, это всего лишь иллюстрация. Несмотря на то, что говорится в этом фрагменте, структура sliceHeader не видна программисту, а тип указателя элемента зависит от типа элементов, но это дает общее представление о механике.

До сих пор мы использовали операцию среза в массиве, но мы также можем срезать срез, например:

```
slice2 := slice[5:10]
```

Как и раньше, эта операция создает новый срез, в данном случае с элементами с 5 по 9 (включительно) исходного среза, что означает элементы со 105 по 109 исходного массива. Базовая структура sliceHeader для переменной slice2 выглядит так:

```
slice2 := sliceHeader{
    Length:        5,
    ZerothElement: &buffer[105],
}
```

Обратите внимание, что этот заголовок по-прежнему указывает на тот же базовый массив, хранящийся в переменной buffer.

Мы также можем срезать срез и сохранить результат обратно в исходной структуре фрагмента. После

```
slice = slice[5:10]
```

структура sliceHeader для переменной slice выглядит так же, как и для переменной slice2. Вы увидите, что повторное использование срезов часто используется, например, для уменьшения среза. Этот оператор удаляет первый и последний элементы нашего среза:

```
slice = slice[1:len(slice)-1]
```

Упражнение: запишите, как будет выглядеть структура sliceHeader после этого присвоения.

Вы часто будете слышать, как опытные программисты Go говорят о «заголовке среза», потому что это действительно то, что хранится в переменной среза. Например, когда вы вызываете функцию, которая принимает срез в качестве аргумента, такую как [bytes.IndexRune](https://golang.org/pkg/bytes/#IndexRune), именно этот заголовок передается в функцию. В этом вызове

```
slashPos := bytes.IndexRune(slice, '/')
```

аргумент среза, который передается в функцию IndexRune, на самом деле является «заголовком среза».

В заголовке среза есть еще один элемент данных, о котором мы поговорим ниже, но сначала давайте посмотрим, что означает существование заголовка среза, когда вы программируете с помощью срезов.

## Передача заголовков в функции

Важно понимать, что даже если срез содержит указатель, он сам является значением. "Под капотом" - это структурное значение, содержащее указатель и длину. Это не указатель на структуру.

Это важно.

Когда мы вызывали IndexRune в предыдущем примере, ему была передана копия заголовка среза. Такое поведение имеет важные следствия.

Рассмотрите эту функцию:

```
func AddOneToEachElement(slice []byte) {
    for i := range slice {
        slice[i]++
    }
}
```

Она делает именно то, что выходит из ее названия, перебирает индексы среза (используя цикл for range), увеличивая его элементы.

Попробуйте запустить:

```
func main() {
    slice := buffer[10:20]
    for i := 0; i < len(slice); i++ {
        slice[i] = byte(i)
    }
    fmt.Println("before", slice)
    AddOneToEachElement(slice)
    fmt.Println("after", slice)
}
```

Результат

```
before [0 1 2 3 4 5 6 7 8 9]
after [1 2 3 4 5 6 7 8 9 10]
```

Несмотря на то, что заголовок среза передается по значению, заголовок включает указатель на элементы массива, поэтому как исходный заголовок среза, так и копия заголовка, переданного в функцию, описывают один и тот же массив. Следовательно, когда функция завершает свою работу, измененные элементы можно увидеть через исходную переменную среза.

Аргумент функции действительно является копией, как показывает этот пример:

```
func SubtractOneFromLength(slice []byte) []byte {
    slice = slice[0 : len(slice)-1]
    return slice
}

func main() {
    fmt.Println("Before: len(slice) =", len(slice))
    newSlice := SubtractOneFromLength(slice)
    fmt.Println("After:  len(slice) =", len(slice))
    fmt.Println("After:  len(newSlice) =", len(newSlice))
}
```

Результат

```
Before: len(slice) = 50
After:  len(slice) = 50
After:  len(newSlice) = 49
```

Здесь мы видим, что содержимое аргумента среза может быть изменено функцией, но его заголовок — нет. Длина, хранящаяся в переменной среза, не изменяется при вызове функции, так как функции передается копия заголовка среза, а не оригинал. Таким образом, если мы хотим написать функцию, изменяющую заголовок, мы должны вернуть его как параметр результата, как мы это сделали здесь. Переменная среза не изменяется, но возвращаемое значение имеет новую длину, которая затем сохраняется в newSlice

## Указатели на срезы: приёмники

Другой способ заставить функцию изменить заголовок среза — передать указатель на него. Вот вариант нашего предыдущего примера, который делает это:

```
func PtrSubtractOneFromLength(slicePtr *[]byte) {
    slice := *slicePtr
    *slicePtr = slice[0 : len(slice)-1]
}

func main() {
    fmt.Println("Before: len(slice) =", len(slice))
    PtrSubtractOneFromLength(&slice)
    fmt.Println("After:  len(slice) =", len(slice))
}
```

Результат

```
Before: len(slice) = 50
After:  len(slice) = 49
```

В этом примере это кажется неуклюжим, особенно когда речь идет о дополнительном уровне косвенности (помогает временная переменная), но есть один общий случай, когда вы видите указатели на срезы. Принято использовать приемник-указатель для метода, изменяющего срез.

Допустим, мы хотели иметь метод для среза, который обрезает его до последней косой черты. Мы могли бы написать это так:

```
type path []byte

func (p *path) TruncateAtFinalSlash() {
    i := bytes.LastIndex(*p, []byte("/"))
    if i >= 0 {
        *p = (*p)[0:i]
    }
}

func main() {
    pathName := path("/usr/bin/tso") // Приведение string в path.
    pathName.TruncateAtFinalSlash()
    fmt.Printf("%s\n", pathName)
}
```

Результат

```
/usr/bin
```

Если вы запустите этот пример, вы увидите, что он работает правильно, обновляя срез в вызывающей программе.

Упражнение: измените тип приемника на значение, а не указатель, и запустите его снова. Объясните, что происходит.

С другой стороны, если бы мы хотели написать метод для пути, который меняет регистр ASCII букв в пути на верхний (ограниченно игнорируя неанглийские имена), метод мог бы быть значением, потому что приемник-значение по-прежнему будет указывать на тот же базовый массив.

```
type path []byte

func (p path) ToUpper() {
    for i, b := range p {
        if 'a' <= b && b <= 'z' {
            p[i] = b + 'A' - 'a'
        }
    }
}

func main() {
    pathName := path("/usr/bin/tso")
    pathName.ToUpper()
    fmt.Printf("%s\n", pathName)
}
```

Результат

```
/USR/BIN/TSO
```

Здесь метод ToUpper использует две переменные в конструкции for range для захвата индекса и элемента среза. Эта форма цикла позволяет избежать многократной записи p[i] в теле.

Упражнение: преобразуйте метод ToUpper для использования приемника-указателя и посмотрите, изменится ли его поведение.

Продвинутое упражнение: преобразование метода ToUpper для обработки букв Unicode, а не только ASCII.

## Емкость

Посмотрите на следующую функцию, которая расширяет свой аргумент (срез целых чисел) на один элемент:

```
func Extend(slice []int, element int) []int {
    n := len(slice)
    slice = slice[0 : n+1]
    slice[n] = element
    return slice
}
```

(Зачем нужно возвращать измененный срез?) Теперь запустите его:

```
func main() {
    var iBuffer [10]int
    slice := iBuffer[0:0]
    for i := 0; i < 20; i++ {
        slice = Extend(slice, i)
        fmt.Println(slice)
    }
}
```

Результат

```
[0]
[0 1]
[0 1 2]
[0 1 2 3]
[0 1 2 3 4]
[0 1 2 3 4 5]
[0 1 2 3 4 5 6]
[0 1 2 3 4 5 6 7]
[0 1 2 3 4 5 6 7 8]
[0 1 2 3 4 5 6 7 8 9]
panic: runtime error: slice bounds out of range [:11] with capacity 10

goroutine 1 [running]:
main.Extend(...)
	/tmp/sandbox751785990/prog.go:16
main.main()
	/tmp/sandbox751785990/prog.go:25 +0x105

Program exited: status 2.
```

Посмотрите, как срез растет, пока ... не перестает.

Пора поговорить о третьем компоненте заголовка среза: его емкости. Помимо указателя массива и длины, заголовок среза также сохраняет его емкость:

```
type sliceHeader struct {
    Length        int
    Capacity      int
    ZerothElement *byte
}
```

В поле Capacity записывается, сколько места на самом деле имеет базовый массив; это максимальное значение, которого может достичь длина. Попытка увеличить срез сверх его вместимости выйдет за пределы массива и вызовет панику.

После создания нашего примера среза

```
slice := iBuffer[0:0]
```

его заголовок выглядит как

```
slice := sliceHeader{
    Length:        0,
    Capacity:      10,
    ZerothElement: &iBuffer[0],
}
```

Поле Capacity равно длине базового массива за вычетом индекса в массиве первого элемента среза (в данном случае — нуля). Если вы хотите узнать, какова емкость среза, используйте встроенную функцию cap:

```
if cap(slice) == len(slice) {
    fmt.Println("slice is full!")
}
```

## Make

Что, если мы хотим вырастить срез сверх его емкости? Вы не можете! По определению, емкость — это предел роста. Но вы можете достичь эквивалентного результата, выделив новый массив, скопировав данные и изменив срез для описания нового массива.

Начнем с аллокации. Мы могли бы использовать встроенную функцию new, чтобы выделить больший массив, а затем нарезать результат, но вместо этого проще использовать встроенную функцию make. Она выделяет новый массив и создает заголовок среза для его описания сразу. Функция make принимает три аргумента: тип среза, его начальную длину и его емкость, которая представляет собой длину массива, который make выделяет для хранения данных среза. Этот вызов создает фрагмент длиной 10 с местом для еще 5 (15-10), как вы можете видеть, запустив его:

```
slice := make([]int, 10, 15)
fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
```

Результат

```
len: 10, cap: 15
```

Этот фрагмент удваивает емкость нашего int среза, но сохраняет его длину прежней:

```
slice := make([]int, 10, 15)
fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
newSlice := make([]int, len(slice), 2*cap(slice))
for i := range slice {
    newSlice[i] = slice[i]
}
slice = newSlice
fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
```

Результат

```
len: 10, cap: 15
len: 10, cap: 30
```

После запуска этого кода у среза появляется гораздо больше возможностей для роста, прежде чем потребуется новое выделение памяти.

При создании срезов часто бывает так, что длина и емкость будут одинаковыми. У встроенной команды make есть сокращение для этого общего случая. В качестве аргумента длины по умолчанию используется емкость, поэтому вы можете не указывать его, чтобы установить для них одинаковое значение. После

```
gophers := make([]Gopher, 10)
```

длина и емкость среза равны 10.

## Copy

Когда мы удвоили емкость нашего среза в предыдущем разделе, мы написали цикл для копирования старых данных в новый срез. Go имеет встроенную функцию копирования, чтобы упростить эту задачу. Ее аргументы представляют собой два среза, и она копирует данные из правого аргумента в левый аргумент. Вот наш пример, переписанный для использования копирования:

```
newSlice := make([]int, len(slice), 2*cap(slice))
copy(newSlice, slice)
```

Функция копирования умная. Она копирует только то, что может, обращая внимание на длину обоих аргументов. Другими словами, количество копируемых элементов равно минимальной длине двух срезов. Это может немного сэкономить написание кода. Кроме того, copy возвращает целочисленное значение — количество скопированных элементов, хотя это не всегда стоит проверять.

Функция копирования также исправляет ситуацию, когда источник и место назначения перекрываются, что означает, что ее можно использовать для перемещения элементов в одном срезе. Вот как использовать копию для вставки значения в середину среза.

```
// Insert вставляет значение в срез по указанному индексу
// который должен быть в диапазоне
// Срез должен иметь место для нового элемента
func Insert(slice []int, index, value int) []int {
    // Увеличиваем срез на один элемент
    slice = slice[0 : len(slice)+1]
    // Используем copy чтобы сдвинуть верхнюю чать среза и освободить место
    copy(slice[index+1:], slice[index:])
    // Записываем значение
    slice[index] = value
    // Возвращаем результат
    return slice
}
```

В этой функции следует обратить внимание на несколько моментов. Во-первых, конечно, он должен вернуть обновленный фрагмент, потому что его длина изменилась. Во-вторых, используется удобное сокращение. Выражение

```
slice[i:]
```

означает то же самое что и

```
slice[i:len(slice)]
```

Кроме того, хотя мы еще не использовали этот прием, мы также можем опустить первый элемент выражения среза; по умолчанию он равен нулю. Таким образом

```
slice[:]
```

просто означает сам срез, что полезно при разрезании массива. Это выражение — самый короткий способ сказать «срез, описывающий все элементы массива»:

```
array[:]
```

Теперь, когда это не мешает, давайте запустим нашу функцию Insert.

```
slice := make([]int, 10, 20) // capacity > length: место для нового эелемента
for i := range slice {
    slice[i] = i
}
fmt.Println(slice)
slice = Insert(slice, 5, 99)
fmt.Println(slice)
```

Результат

```
[0 1 2 3 4 5 6 7 8 9]
[0 1 2 3 4 99 5 6 7 8 9]
```

## Append: пример

Несколькими разделами назад мы написали функцию Extend, которая расширяет срез на один элемент. Однако она имела недостаток — потому что, если емкость среза была бы слишком мала, то функция вышла бы из строя. (В нашем примере Insert имеет ту же проблему.) Теперь у нас есть все необходимое, чтобы исправить это, поэтому давайте напишем надежную реализацию Extend для целочисленных срезов.

```
func Extend(slice []int, element int) []int {
    n := len(slice)
    if n == cap(slice) {
        // Срез полный, необходимо увеличение
        // Мы удвоим его размер и добавим 1, так, чтобы если размер был бы 0 - мы по прежнему могли бы увеличить его
        newSlice := make([]int, len(slice), 2*len(slice)+1)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0 : n+1]
    slice[n] = element
    return slice
}
```

В этом случае особенно важно вернуть срез, так как при перераспределении результирующего среза описывается совершенно другой массив. Вот небольшой фрагмент, демонстрирующий, что происходит при заполнении среза:

```
slice := make([]int, 0, 5)
for i := 0; i < 10; i++ {
    slice = Extend(slice, i)
    fmt.Printf("len=%d cap=%d slice=%v\n", len(slice), cap(slice), slice)
    fmt.Println("address of 0th element:", &slice[0])
}
```

Результат

```
len=1 cap=5 slice=[0]
address of 0th element: 0xc0000b2030
len=2 cap=5 slice=[0 1]
address of 0th element: 0xc0000b2030
len=3 cap=5 slice=[0 1 2]
address of 0th element: 0xc0000b2030
len=4 cap=5 slice=[0 1 2 3]
address of 0th element: 0xc0000b2030
len=5 cap=5 slice=[0 1 2 3 4]
address of 0th element: 0xc0000b2030
len=6 cap=11 slice=[0 1 2 3 4 5]
address of 0th element: 0xc000094060
len=7 cap=11 slice=[0 1 2 3 4 5 6]
address of 0th element: 0xc000094060
len=8 cap=11 slice=[0 1 2 3 4 5 6 7]
address of 0th element: 0xc000094060
len=9 cap=11 slice=[0 1 2 3 4 5 6 7 8]
address of 0th element: 0xc000094060
len=10 cap=11 slice=[0 1 2 3 4 5 6 7 8 9]
address of 0th element: 0xc000094060
```

Обратите внимание на перераспределение при заполнении исходного массива размером 5. И емкость, и адрес нулевого элемента меняются при выделении нового массива.

С помощью надежной функции Extend в качестве руководства мы можем написать еще более удобную функцию, которая позволяет нам расширять фрагмент на несколько элементов. Для этого мы используем способность Go превращать список аргументов функции в срез при вызове функции. То есть мы используем возможность вариативной функции Go.

Назовем функцию Append. Для первой версии мы можем просто многократно вызывать Extend, чтобы был понятен механизм вариативной функции. Сигнатура Append такая:

```
func Append(slice []int, items ...int) []int
```

Это говорит о том, что Append принимает один аргумент, срез, за которым следует ноль или более аргументов типа int. Эти аргументы представляют собой в точности часть int в том, что касается реализации Append, как вы можете видеть:

```
// Append добавляет элементы в срез.
// Первая версия: просто итеративно вызываем Extend.
func Append(slice []int, items ...int) []int {
    for _, item := range items {
        slice = Extend(slice, item)
    }
    return slice
}
```

Обратите внимание на цикл for range, перебирающий элементы аргумента items, который подразумевает type [] int. Также обратите внимание на использование пустого идентификатора _, чтобы отбросить индекс в цикле, который нам в данном случае не нужен.

Попробуйте запустить

```
slice := []int{0, 1, 2, 3, 4}
fmt.Println(slice)
slice = Append(slice, 5, 6, 7, 8)
fmt.Println(slice)
```

Результат

```
[0 1 2 3 4]
[0 1 2 3 4 5 6 7 8]
```

Еще одна новая техника в этом примере заключается в том, что мы инициализируем срез, записывая составной литерал, который состоит из типа среза, за которым следуют его элементы в фигурных скобках:

```
slice := []int{0, 1, 2, 3, 4}
```

Функция Append интересна еще по одной причине. Мы можем не только добавлять элементы, но и целый второй срез, "разбивая" срез на аргументы, используя нотацию "..." в месте вызова:

```
slice1 := []int{0, 1, 2, 3, 4}
slice2 := []int{55, 66, 77}
fmt.Println(slice1)
slice1 = Append(slice1, slice2...) // The '...' is essential!
fmt.Println(slice1)
```

Результат

```
[0 1 2 3 4]
[0 1 2 3 4 55 66 77]
```

Конечно, мы можем сделать Append более эффективным, выделяя память не более одного раза, опираясь на реализацию Extend:

```
// Append добавляет элементы в срез.
// Эффективная версия.
func Append(slice []int, elements ...int) []int {
    n := len(slice)
    total := len(slice) + len(elements)
    if total > cap(slice) {
        // Выделяем память. Увеличиваем в 1.5 раза новый размер так, что мы можем еще увеличивать
        newSize := total*3/2 + 1
        newSlice := make([]int, total, newSize)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[:total]
    copy(slice[n:], elements)
    return slice
}
```

Здесь обратите внимание на то, как мы используем копию дважды: один раз для перемещения данных среза во вновь выделенную память, а затем для копирования добавляемых элементов в конец старых данных.

Попробуй запустить; поведение такое же, как и раньше:

```
slice1 := []int{0, 1, 2, 3, 4}
slice2 := []int{55, 66, 77}
fmt.Println(slice1)
slice1 = Append(slice1, slice2...) // The '...' is essential!
fmt.Println(slice1)
```

Результат

```
[0 1 2 3 4]
[0 1 2 3 4 55 66 77]
```

## Append: встроенная функция

Итак, мы подошли к мотивации для разработки встроенной функции append. Она делает то же самое, что и наш пример Append, с эквивалентной эффективностью, но работает для любого типа среза.

A weakness of Go is that any generic-type operations must be provided by the run-time (примечание переводчика: предположительно, Роб Пайк хотел указать на одно из слабых мест в Go - отсутствие [дженериков](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) и связанные с этим расходы на память). Когда-нибудь это может измениться, но сейчас, чтобы упростить работу со срезами, Go предоставляет встроенную универсальную функцию добавления. Он работает так же, как наша версия среза int, но для любого типа среза.

Помните, что поскольку заголовок среза всегда обновляется вызовом append, вам необходимо сохранить возвращенный срез после вызова. Фактически, компилятор не позволит вам вызвать append без сохранения результата.

Вот несколько однострочников, смешанных с операторами вывода. Попробуйте их, отредактируйте и исследуйте:

```
// Создаем пару начальных срезов.
slice := []int{1, 2, 3}
slice2 := []int{55, 66, 77}
fmt.Println("Start slice: ", slice)
fmt.Println("Start slice2:", slice2)

// Добавляем элемент в срез.
slice = append(slice, 4)
fmt.Println("Add one item:", slice)

// Добавляем один срез к другому.
slice = append(slice, slice2...)
fmt.Println("Add one slice:", slice)

// Делаем копию среза чисел.
slice3 := append([]int(nil), slice...)
fmt.Println("Copy a slice:", slice3)

// Копируем срез в конец себя.
fmt.Println("Before append to self:", slice)
slice = append(slice, slice...)
fmt.Println("After append to self:", slice)
```

Результат

```
Start slice:  [1 2 3]
Start slice2: [55 66 77]
Add one item: [1 2 3 4]
Add one slice: [1 2 3 4 55 66 77]
Copy a slice: [1 2 3 4 55 66 77]
Before append to self: [1 2 3 4 55 66 77]
After append to self: [1 2 3 4 55 66 77 1 2 3 4 55 66 77]
```

Стоит уделить время тому, чтобы подробно обдумать последний однострочный пример, чтобы понять, как конструкция срезов делает возможным правильную работу этого простого вызова.

Есть еще много примеров добавления, копирования и других способов использования срезов на созданной сообществом вики-странице [Slice Tricks](https://github.com/golang/go/wiki/SliceTricks).

## Nil

Кстати, с нашими новооткрытыми знаниями мы можем увидеть, что представляет собой нулевой срез (nil slice). Естественно, это нулевое значение заголовка среза:

```
sliceHeader{
    Length:        0,
    Capacity:      0,
    ZerothElement: nil,
}
```

или просто

```
sliceHeader{}
```

Ключевой деталью является то, что указатель элемента тоже равен нулю. Срез, созданный посредством

```
array[0:0]
```

имеет нулевую длину (и, возможно, даже нулевую емкость), но его указатель не равен нулю, поэтому это не нулевой срез.

Как должно быть очевидно, пустой срез может увеличиваться (при условии, что он имеет ненулевую емкость), но нулевой срез не имеет массива для ввода значений и никогда не может увеличиваться, чтобы содержать хотя бы один элемент.

Тем не менее, нулевой срез функционально эквивалентен срезу нулевой длины, даже если он ни на что не указывает. Он имеет нулевую длину и может быть добавлен с выделением. В качестве примера посмотрите приведенный выше однострочник, который копирует срез, добавляя его к нулевому срезу.

## Strings

Теперь краткий раздел о строках в Go в контексте срезов.

Строки на самом деле очень просты: это просто срезы байт, доступные только для чтения, с небольшой дополнительной синтаксической поддержкой языка.

Поскольку они предназначены только для чтения, нет необходимости в емкости (вы не можете их увеличивать), но в остальном для большинства целей вы можете обращаться с ними как со срезами байт, доступными только для чтения.

Для начала мы можем проиндексировать их для доступа к отдельным байтам:

```
slash := "/usr/ken"[0] // возвращает значение байта '/'.
```

Мы можем срезать строку, чтобы получить подстроку:

```
usr := "/usr/ken"[0:4] // возваращает строку "/usr"
```

Теперь должно быть очевидно, что происходит за кулисами, когда мы срезаем строку.

Мы также можем взять обычный срез байт и создать из него строку с помощью простого преобразования:

```
str := string(slice)
```

и идем в обратном направлении:

```
slice := []byte(usr)
```

Массив, лежащий в основе строки, скрыт от просмотра; нет другого способа получить доступ к его содержимому, кроме как через строку. Это означает, что когда мы выполняем любое из этих преобразований, должна быть сделана копия массива. Go, конечно, позаботится об этом, вам не нужно об этом беспокоиться. После любого из этих преобразований изменения в массиве, лежащем в основе байтового среза, не влияют на соответствующую строку.

Важным следствием подобной конструкции срезов строк является то, что создание подстроки очень эффективно. All that needs to happen is the creation of a two-word string header. Поскольку строка предназначена только для чтения, исходная строка и строка, полученная в результате операции среза, могут безопасно совместно использовать один и тот же массив.

Историческое примечание: самая ранняя реализация строк всегда подразумевала выделение памяти, но, когда в язык добавлялись срезы, они предоставили модель для эффективной обработки строк. В результате некоторые тесты показали значительное ускорение.

Конечно, строки — это гораздо больше, и [отдельный пост в блоге](https://blog.golang.org/strings) освещает их более подробно.

## Заключение

Чтобы понять, как работают срезы, полезно понять, как они реализованы. Есть небольшая структура данных, заголовок среза, который является элементом, связанным с переменной среза, и этот заголовок описывает раздел отдельно выделенного массива. Когда мы передаем значения срезов, заголовок копируется, но массив, на который он указывает, всегда используется совместно.

Как только вы поймете, как они работают, срезы станут не только простыми в использовании, но и мощными и выразительными, особенно с помощью встроенных функций copy и append.

## Прочитать больше

В сети есть много чего найти о срезах в Go. Как упоминалось ранее, ["Slice Tricks" Wiki page](https://github.com/golang/go/wiki/SliceTricks) имеет много примеров. В статье блога [Go Slices](https://blog.golang.org/slices-intro) подробно описаны детали структуры памяти с четкими диаграммами. Статья Расса Кокса [Go Data Structures](https://research.swtch.com/godata) включает обсуждение срезов вместе с некоторыми другими внутренними структурами данных Go.

Доступно гораздо больше материала, но лучший способ узнать о срезах — это использовать их.
