Source https://blog.golang.org/slices
Author: Rob Pike 26 September 2013

# Массивы, срезы (и строки): Механизм append


https://blog.golang.org/slices

## Вступление

Одна из наиболее распространенных особенностей процедурных языков программирования - это концепция массива. Массивы кажутся простыми вещами, но есть много вопросов, на которые необходимо ответить при их добавлении в язык, например:

- фиксированного или переменного размера?
- является ли размер частью типа?
- как выглядят многомерные массивы?
- имеет ли смысл пустой массив?

Ответы на эти вопросы влияют на то, являются ли массивы просто возможностью языка или его базовой частью его дизайна.

На раннем этапе разработки Go потребовалось около года, чтобы найти ответы на эти вопросы, прежде чем дизайн стал правильным. Ключевым шагом было введение срезов, которые построены на массивах фиксированного размера, чтобы дать гибкую, расширяемую структуру данных. Однако до сих пор программисты, плохо знакомые с Go, часто спотыкаются о том, как работают срезы, возможно из-за влияния опыта других языков.

В этом посте мы попытаемся устранить путаницу. Мы это сделаем, собрав некоторые части вместе, чтобы объяснить, как работает встроенная функция append и почему она работает именно так.

## Массивы

Массивы являются важным строительным блоком в Go, но, как и фундамент здания, они часто скрыты под более видимыми компонентами. Мы должны кратко поговорить о них, прежде чем перейти к более интересной, мощной и заметной идее срезов.

Массивы нечасто встречаются в программах Go, потому что размер массива является частью его типа, что ограничивает его выразительные возможности.

Выражение

```
var buffer [256]byte
```

объявит переменную buffer, которая будет содержать массив из 256 байт. Тип переменной buffer включает размер, [256]byte. Массив из 512 байт имел бы отличный тип [512]byte.

Данные, связанные с массивом — это просто массив элементов. Схематично наш буфер в памяти выглядит так

```
buffer: byte byte byte ... 256 раз ... byte byte byte
```

То есть переменная содержит 256 байтов данных и ничего больше. Мы можем получить доступ к его элементам с помощью знакомого синтаксиса индексации, buffer [0], buffer [1] и т. Д. до buffer [255]. (Диапазон индекса от 0 до 255 охватывает 256 элементов.) Попытка индексировать буфер со значением вне этого диапазона приведет к сбою программы.

Существует встроенная функция len, которая возвращает количество элементов массива или среза, а также, для нескольких других типов данных. Для массивов очевидно, что возвращает len. В нашем примере len(buffer) возвращает фиксированное значение 256.

У массивов есть свое место — например, они являются хорошим представлением матрицы преобразования, но их наиболее распространенная цель в Go - хранить память для среза.

## Срезы: заголовок среза

Срезы — это то место, где происходит действие, но, чтобы правильно их использовать, нужно точно понимать, что они из себя представляют и что они делают.

Срез — это структура данных, описывающая непрерывный раздел массива, хранящийся отдельно от самой переменной среза. Срез — это не массив. Срез описывает часть массива.

Учитывая нашу переменную буферного массива из предыдущего раздела, мы могли бы создать срез, который описывает элементы от 100 до 150 (точнее, от 100 до 149 включительно), срезав массив:

```
var slice []byte = buffer[100:150]
```

В этом фрагменте мы использовали полное объявление переменной, чтобы быть явным. Переменный срез имеет тип []byte, произносится как «срез байтов», и инициализируется из массива, называемого буфером, путем разделения элементов с 100 (включительно) до 150 (исключая). Более идиоматический синтаксис отбрасывает тип, который задается инициализирующим выражением:

```
var slice = buffer[100:150]
```

Внутри функции мы могли бы использовать короткую форму объявления

```
slice := buffer[100:150]
```

Что именно представляет собой эта переменная среза? Мы имеем не совсем полную картину, но пока представьте себе срез как небольшую структуру данных с двумя элементами: длиной и указателем на элемент массива. Вы можете думать об этом как о чем то созданном за кулисами:

```
type sliceHeader struct {
    Length        int
    ZerothElement *byte
}

slice := sliceHeader{
    Length:        50,
    ZerothElement: &buffer[100],
}
```

Конечно, это всего лишь иллюстрация. Несмотря на то, что говорится в этом фрагменте, структура sliceHeader не видна программисту, а тип указателя элемента зависит от типа элементов, но это дает общее представление о механике.

До сих пор мы использовали операцию среза в массиве, но мы также можем срезать срез, например:

```
slice2 := slice[5:10]
```

Как и раньше, эта операция создает новый слайс, в данном случае с элементами с 5 по 9 (включительно) исходного слайса, что означает элементы со 105 по 109 исходного массива. Базовая структура sliceHeader для переменной slice2 выглядит так:

```
slice2 := sliceHeader{
    Length:        5,
    ZerothElement: &buffer[105],
}
```

Обратите внимание, что этот заголовок по-прежнему указывает на тот же базовый массив, хранящийся в переменной buffer.

Мы также можем срезать срез и сохранить результат обратно в исходной структуре фрагмента. После

```
slice = slice[5:10]
```

структура sliceHeader для переменной slice выглядит так же, как и для переменной slice2. Вы увидите, что повторное использование срезов часто используется, например, для усечения среза. Этот оператор удаляет первый и последний элементы нашего среза:

```
slice = slice[1:len(slice)-1]
```

Упражнение: запишите, как будет выглядеть структура sliceHeader после этого присвоения.

Вы часто будете слышать, как опытные программисты Go говорят о «заголовке среза», потому что это действительно то, что хранится в переменной среза. Например, когда вы вызываете функцию, которая принимает срез в качестве аргумента, такую как [bytes.IndexRune](https://golang.org/pkg/bytes/#IndexRune), именно этот заголовок передается в функцию. В этом вызове

```
slashPos := bytes.IndexRune(slice, '/')
```

аргумент среза, который передается в функцию IndexRune, на самом деле является «заголовком среза».

В заголовке среза есть еще один элемент данных, о котором мы поговорим ниже, но сначала давайте посмотрим, что означает существование заголовка среза, когда вы программируете с помощью срезов.

## Передача заголовков в функции

Важно понимать, что даже если фрагмент содержит указатель, он сам является значением. "Под капотом" - это структурное значение, содержащее указатель и длину. Это не указатель на структуру.

Это имеет значение.

Когда мы вызывали IndexRune в предыдущем примере, ему была передана копия заголовка среза. Такое поведение имеет важные следствия.

Рассмотрите эту функцию:

```
func AddOneToEachElement(slice []byte) {
    for i := range slice {
        slice[i]++
    }
}
```

Она делает именно то, что выходит из ее названия, перебирает индексы среза (используя цикл for range), увеличивая его элементы.

Попробуйте запустить:

```
func main() {
    slice := buffer[10:20]
    for i := 0; i < len(slice); i++ {
        slice[i] = byte(i)
    }
    fmt.Println("before", slice)
    AddOneToEachElement(slice)
    fmt.Println("after", slice)
}
```

Результат

```
before [0 1 2 3 4 5 6 7 8 9]
after [1 2 3 4 5 6 7 8 9 10]
```

Несмотря на то, что заголовок среза передается по значению, заголовок включает указатель на элементы массива, поэтому как исходный заголовок среза, так и копия заголовка, переданного в функцию, описывают один и тот же массив. Следовательно, когда функция возвращается, измененные элементы можно увидеть через исходную переменную среза.

Аргумент функции действительно является копией, как показывает этот пример:

```
func SubtractOneFromLength(slice []byte) []byte {
    slice = slice[0 : len(slice)-1]
    return slice
}

func main() {
    fmt.Println("Before: len(slice) =", len(slice))
    newSlice := SubtractOneFromLength(slice)
    fmt.Println("After:  len(slice) =", len(slice))
    fmt.Println("After:  len(newSlice) =", len(newSlice))
}
```

Результат

```
Before: len(slice) = 50
After:  len(slice) = 50
After:  len(newSlice) = 49
```

Здесь мы видим, что содержимое аргумента среза может быть изменено функцией, но его заголовок — нет. Длина, хранящаяся в переменной среза, не изменяется при вызове функции, так как функции передается копия заголовка среза, а не оригинал. Таким образом, если мы хотим написать функцию, изменяющую заголовок, мы должны вернуть ее как параметр результата, как мы это сделали здесь. Переменная среза не изменяется, но возвращаемое значение имеет новую длину, которая затем сохраняется в newSlice,

## Указатели на срезы: приёмники

Другой способ заставить функцию изменить заголовок среза — передать указатель на него. Вот вариант нашего предыдущего примера, который делает это:

```
func PtrSubtractOneFromLength(slicePtr *[]byte) {
    slice := *slicePtr
    *slicePtr = slice[0 : len(slice)-1]
}

func main() {
    fmt.Println("Before: len(slice) =", len(slice))
    PtrSubtractOneFromLength(&slice)
    fmt.Println("After:  len(slice) =", len(slice))
}
```

Результат

```
Before: len(slice) = 50
After:  len(slice) = 49
```

В этом примере это кажется неуклюжим, особенно когда речь идет о дополнительном уровне косвенности (помогает временная переменная), но есть один общий случай, когда вы видите указатели на срезы. Принято использовать приемник указателя для метода, изменяющего срез.

Допустим, мы хотели иметь метод для среза, который обрезает его до последней косой черты. Мы могли бы написать это так:

```
type path []byte

func (p *path) TruncateAtFinalSlash() {
    i := bytes.LastIndex(*p, []byte("/"))
    if i >= 0 {
        *p = (*p)[0:i]
    }
}

func main() {
    pathName := path("/usr/bin/tso") // Conversion from string to path.
    pathName.TruncateAtFinalSlash()
    fmt.Printf("%s\n", pathName)
}
```

Результат

```
/usr/bin
```

Если вы запустите этот пример, вы увидите, что он работает правильно, обновляя срез в вызывающей программе.

Упражнение: измените тип получателя на значение, а не указатель, и запустите его снова. Объясните, что происходит.

С другой стороны, если бы мы хотели написать метод для пути, который меняет регистр ASCII букв в пути на верхний (ограниченно игнорируя неанглийские имена), метод мог бы быть значением, потому что приемник-значение по-прежнему будет указывать на тот же базовый массив.

```
type path []byte

func (p path) ToUpper() {
    for i, b := range p {
        if 'a' <= b && b <= 'z' {
            p[i] = b + 'A' - 'a'
        }
    }
}

func main() {
    pathName := path("/usr/bin/tso")
    pathName.ToUpper()
    fmt.Printf("%s\n", pathName)
}
```

Результат

```
/USR/BIN/TSO
```

Здесь метод ToUpper использует две переменные в конструкции for range для захвата индекса и элемента среза. Эта форма цикла позволяет избежать многократной записи p[i] в теле.

Упражнение: преобразуйте метод ToUpper для использования приемника-указателя и посмотрите, изменится ли его поведение.

Продвинутое упражнение: преобразование метода ToUpper для обработки букв Unicode, а не только ASCII.

## Емкость

Посмотрите на следующую функцию, которая расширяет свой аргумент (срез целых чисел) на один элемент:

```
func Extend(slice []int, element int) []int {
    n := len(slice)
    slice = slice[0 : n+1]
    slice[n] = element
    return slice
}
```

(Зачем нужно возвращать измененный срез?) Теперь запустите его:

```
func main() {
    var iBuffer [10]int
    slice := iBuffer[0:0]
    for i := 0; i < 20; i++ {
        slice = Extend(slice, i)
        fmt.Println(slice)
    }
}
```

Результат

```
[0]
[0 1]
[0 1 2]
[0 1 2 3]
[0 1 2 3 4]
[0 1 2 3 4 5]
[0 1 2 3 4 5 6]
[0 1 2 3 4 5 6 7]
[0 1 2 3 4 5 6 7 8]
[0 1 2 3 4 5 6 7 8 9]
panic: runtime error: slice bounds out of range [:11] with capacity 10

goroutine 1 [running]:
main.Extend(...)
	/tmp/sandbox751785990/prog.go:16
main.main()
	/tmp/sandbox751785990/prog.go:25 +0x105

Program exited: status 2.
```

Посмотрите, как срез растет, пока ... не перестает.

Пора поговорить о третьем компоненте заголовка среза: его емкости. Помимо указателя массива и длины заголовок среза также сохраняет его емкость:

```
type sliceHeader struct {
    Length        int
    Capacity      int
    ZerothElement *byte
}
```

В поле Capacity записывается, сколько места на самом деле имеет базовый массив; это максимальное значение, которого может достичь длина. Попытка увеличить срез сверх его вместимости выйдет за пределы массива и вызовет панику.

После создания нашего примера среза

```
slice := iBuffer[0:0]
```

его заголовок выглядит как

```
slice := sliceHeader{
    Length:        0,
    Capacity:      10,
    ZerothElement: &iBuffer[0],
}
```

Поле Capacity равно длине базового массива за вычетом индекса в массиве первого элемента среза (в данном случае — нуля). Если вы хотите узнать, какова емкость среза, используйте встроенную функцию cap:

```
if cap(slice) == len(slice) {
    fmt.Println("slice is full!")
}
```

## Make

Что, если мы хотим вырастить срез сверх его емкости? Вы не можете! По определению, емкость — это предел роста. Но вы можете достичь эквивалентного результата, выделив новый массив, скопировав данные и изменив срез для описания нового массива.

Начнем с аллокации. Мы могли бы использовать новую встроенную функцию, чтобы выделить больший массив, а затем нарезать результат, но вместо этого проще использовать встроенную функцию make. Она выделяет новый массив и создает заголовок фрагмента для его описания сразу. Функция make принимает три аргумента: тип среза, его начальную длину и его емкость, которая представляет собой длину массива, который make выделяет для хранения данных среза. Этот вызов создает фрагмент длиной 10 с местом для еще 5 (15-10), как вы можете видеть, запустив его:

```
slice := make([]int, 10, 15)
fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
```

Результат

```
len: 10, cap: 15
```

Этот фрагмент удваивает емкость нашего int среза, но сохраняет его длину прежней:

```
slice := make([]int, 10, 15)
fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
newSlice := make([]int, len(slice), 2*cap(slice))
for i := range slice {
    newSlice[i] = slice[i]
}
slice = newSlice
fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
```

Результат

```
len: 10, cap: 15
len: 10, cap: 30
```

После запуска этого кода у среза появляется гораздо больше возможностей для роста, прежде чем потребуется новое выделение памяти.

При создании срезов часто бывает так, что длина и емкость будут одинаковыми. У встроенной команды make есть сокращение для этого общего случая. В качестве аргумента длины по умолчанию используется емкость, поэтому вы можете не указывать его, чтобы установить для них одинаковое значение. После

```
gophers := make([]Gopher, 10)
```

длина и емкость среза равны 10.

## Copy

Когда мы удвоили емкость нашего среза в предыдущем разделе, мы написали цикл для копирования старых данных в новый срез. Go имеет встроенную функцию копирования, чтобы упростить эту задачу. Ее аргументы представляют собой два среза, и она копирует данные из правого аргумента в левый аргумент. Вот наш пример, переписанный для использования копирования:

```
newSlice := make([]int, len(slice), 2*cap(slice))
copy(newSlice, slice)
```

Результат

```
len: 10, cap: 15
len: 10, cap: 30
```

Функция копирования умная. Она копирует только то, что может, обращая внимание на длину обоих аргументов. Другими словами, количество копируемых элементов равно минимальной длине двух срезов. Это может немного сэкономить написание кода. Кроме того, copy возвращает целочисленное значение — количество скопированных элементов, хотя это не всегда стоит проверять.

Функция копирования также исправляет ситуацию, когда источник и место назначения перекрываются, что означает, что ее можно использовать для перемещения элементов в одном срезе. Вот как использовать копию для вставки значения в середину среза.

```
// Insert вставляет значение в срез по указанному индексу
// который должен быть в диапазоне
// Срез должен иметь место для нового элемента
func Insert(slice []int, index, value int) []int {
    // Увеличиваем срез на один элемент
    slice = slice[0 : len(slice)+1]
    // Используем copy чтобы сдвинуть верхнюю чать среза и освободить место
    copy(slice[index+1:], slice[index:])
    // Записываем значение
    slice[index] = value
    // Возвращаем результат
    return slice
}
```

В этой функции следует обратить внимание на несколько моментов. Во-первых, конечно, он должен вернуть обновленный фрагмент, потому что его длина изменилась. Во-вторых, используется удобное сокращение. Выражение

```
slice[i:]
```

означает то же самое что и

```
slice[i:len(slice)]
```

Кроме того, хотя мы еще не использовали этот прием, мы также можем опустить первый элемент выражения среза; по умолчанию он равен нулю. Таким образом

```
slice[:]
```

просто означает сам срез, что полезно при разрезании массива. Это выражение — самый короткий способ сказать «срез, описывающий все элементы массива»:

```
array[:]
```

Теперь, когда это не мешает, давайте запустим нашу функцию Insert.

```
slice := make([]int, 10, 20) // capacity > length: место для нового эелемента
for i := range slice {
    slice[i] = i
}
fmt.Println(slice)
slice = Insert(slice, 5, 99)
fmt.Println(slice)
```

Результат

```
[0 1 2 3 4 5 6 7 8 9]
[0 1 2 3 4 99 5 6 7 8 9]
```

## Append: пример

Несколькими разделами назад мы написали функцию Extend, которая расширяет срез на один элемент. Однако она имела недостаток — потому что, если емкость среза была бы слишком мала, то функция вышла бы из строя. (В нашем примере Insert имеет ту же проблему.) Теперь у нас есть все необходимое, чтобы исправить это, поэтому давайте напишем надежную реализацию Extend для целочисленных срезов.

```
func Extend(slice []int, element int) []int {
    n := len(slice)
    if n == cap(slice) {
        // Срез полный, необходимо увеличение
        // Мы удвоим его размер и добавим 1, так, чтобы если размер был бы 0 - мы по прежнему могли бы увеличить его
        newSlice := make([]int, len(slice), 2*len(slice)+1)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0 : n+1]
    slice[n] = element
    return slice
}
```

